<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Lightweight Cryptography Primitives: Utilities for masked ciphers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Lightweight Cryptography Primitives
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Utilities for masked ciphers </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#masking_references">References</a></li>
<li class="level1"><a href="#masking_power_analysis">Why do we need masking?</a></li>
<li class="level1"><a href="#masking_what">What is masking?</a></li>
<li class="level1"><a href="#masking_example">Example: Bit-sliced GIFT-128</a></li>
<li class="level1"><a href="#masking_types">Types</a></li>
<li class="level1"><a href="#masking_operations">Operations</a></li>
<li class="level1"><a href="#masking_work">How do the operations work?</a><ul><li class="level2"><a href="#masking_io">Input and output</a></li>
<li class="level2"><a href="#masking_xor">XOR</a></li>
<li class="level2"><a href="#masking_not">NOT</a></li>
<li class="level2"><a href="#masking_and">AND</a></li>
<li class="level2"><a href="#masking_and_not">AND-NOT</a></li>
<li class="level2"><a href="#masking_or">OR</a></li>
<li class="level2"><a href="#masking_rotates">Shift and rotate</a></li>
<li class="level2"><a href="#masking_swap">Swap</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>This page describes the utilities in the library that support the implementation of masked ciphers in plain C.</p>
<h1><a class="anchor" id="masking_references"></a>
References</h1>
<p>R. Cramer, I. Damgård, and Y. Ishai. <em>Share Conversion, Pseudorandom Secret-Sharing and Applications to Secure Computation</em>. In J. Kilian, editor, Theory of Cryptography Conference – TCC 2005, volume 3378 of Lecture Notes in Computer Science, pages 342–362. Springer, 2005, <a href="https://iacr.org/archive/tcc2005/3378_342/3378_342.pdf">PDF</a>.</p>
<p>Matthieu Rivain and Emmanuel Prouff. <em>Provably secure higher-order masking of AES</em>. In Stefan Mangard and François-Xavier Standaert, editors, CHES, volume 6225 of Lecture Notes in Computer Science, pages 413–427.Springer, 2010, <a href="https://eprint.iacr.org/2010/441.pdf">PDF</a>.</p>
<h1><a class="anchor" id="masking_power_analysis"></a>
Why do we need masking?</h1>
<p>Applications in embedded devices may encrypt or decrypt many times with the same key, either because the key is fixed into the device, or the same key is used on every packet in a session.</p>
<p>Each time the key is used, the power consumption of the device will fluctuate slightly based on the 0 and 1 bits from the key and the plaintext data. Over time it is possible to build up a statistical profile of a particular key's power consumption compared with other keys.</p>
<p>In the simplest form, encrypting with a 1 bit from the key uses a different amount of power than encrypting with a 0 bit. If the power consumption can be measured accurately enough, it may be possible to simply read the bits from the power consumption trace. This is called Simple Power Analysis (SPA).</p>
<p>SPA has historically been used to break RSA encryption on embedded devices. A zero bit involves a square operation, and a 1 bit involves square-and-multiply. The difference in power consumption means that the 0 and 1 bits of the RSA key can be literally read straight off an oscilloscope's screen.</p>
<p>A more powerful technique is Differential Power Analysis (DPA) which can pull useful information out of otherwise noisy data given enough statistical samples. The power consumption will bias one way or the other based on the key in a manner that DPA can detect.</p>
<p>More information on power analysis: <a href="https://en.wikipedia.org/wiki/Power_analysis">https://en.wikipedia.org/wiki/Power_analysis</a></p>
<h1><a class="anchor" id="masking_what"></a>
What is masking?</h1>
<p>Masking is a technique to mitigate against power analysis side channels. For a traditional block cipher, the key and the plaintext input are split up into multiple random "shares", the cipher is applied to each of the shares, and then the results are combined to produce the expected result.</p>
<p>Consider a classical block cipher operation E(K, P) which encrypts a plaintext P under a key K. We can split this into three shares as follows:</p>
<ul>
<li>Generate random values K2, K3, P2, and P3. </li>
<li>Mask K by replacing it with "K ⊕ K2 ⊕ K3" (where ⊕ is the XOR operation). </li>
<li>Mask P by replacing it with "P ⊕ P2 ⊕ P3". </li>
<li>Compute E(K ⊕ K2 ⊕ K3, P ⊕ P2 ⊕ P3), E(K2, P2), and E(K3, P3) in parallel. </li>
<li>XOR the results together to produce the final ciphertext.</li>
</ul>
<p>Because the values K2, K3, P2, and P3 are different every time the block operation is invoked, it is difficult for SPA and DPA to collect usable statistical data and the attack is mitigated. There may still be other ways to recover the key, such as directly hacking into the device and stealing it, but power analysis is made more difficult.</p>
<p>The complexity of masking comes in the fourth step above: computing the three block operations in parallel. If the block cipher involves only XOR, rotate, and shift operations, then it truly can be computed in parallel with no interaction between the shares until the results are combined at the end.</p>
<p>However, all secure ciphers will also include AND and OR operations to mix the data more thoroughly. As we'll see below, this introduces some complexity into the calculations. The utilities in this library handle the complexity to make it easier to write plain C code that uses masking.</p>
<h1><a class="anchor" id="masking_example"></a>
Example: Bit-sliced GIFT-128</h1>
<p>We begin with an example of converting parts of the bit-sliced version of GIFT-128 into masked form.</p>
<p>At the start of a GIFT-128 encryption operation, the 128-bit plaintext input and the 128-bit key are loaded into 32-bit registers from the big-endian input buffers:</p>
<div class="fragment"><div class="line">uint32_t s0 = be_load_word32(input);</div>
<div class="line">uint32_t s1 = be_load_word32(input + 4);</div>
<div class="line">uint32_t s2 = be_load_word32(input + 8);</div>
<div class="line">uint32_t s3 = be_load_word32(input + 12);</div>
<div class="line"></div>
<div class="line">uint32_t k0 = be_load_word32(key);</div>
<div class="line">uint32_t k1 = be_load_word32(key + 4);</div>
<div class="line">uint32_t k2 = be_load_word32(key + 8);</div>
<div class="line">uint32_t k3 = be_load_word32(key + 12);</div>
</div><!-- fragment --><p>Using the masking utilities, this becomes:</p>
<div class="fragment"><div class="line"><a class="code" href="structmask__x4__uint32__t.html">mask_uint32_t</a> s0, s1, s2, s3;</div>
<div class="line"><a class="code" href="structmask__x4__uint32__t.html">mask_uint32_t</a> k0, k1, k2, k3;</div>
<div class="line"></div>
<div class="line"><a class="code" href="internal-masking_8h.html#ad3a968683c09d553a80dd6cfd67093ec">mask_input</a>(s0, be_load_word32(input));</div>
<div class="line"><a class="code" href="internal-masking_8h.html#ad3a968683c09d553a80dd6cfd67093ec">mask_input</a>(s1, be_load_word32(input + 4));</div>
<div class="line"><a class="code" href="internal-masking_8h.html#ad3a968683c09d553a80dd6cfd67093ec">mask_input</a>(s2, be_load_word32(input + 8));</div>
<div class="line"><a class="code" href="internal-masking_8h.html#ad3a968683c09d553a80dd6cfd67093ec">mask_input</a>(s3, be_load_word32(input + 12));</div>
<div class="line"></div>
<div class="line"><a class="code" href="internal-masking_8h.html#ad3a968683c09d553a80dd6cfd67093ec">mask_input</a>(k0, be_load_word32(key));</div>
<div class="line"><a class="code" href="internal-masking_8h.html#ad3a968683c09d553a80dd6cfd67093ec">mask_input</a>(k1, be_load_word32(key + 4));</div>
<div class="line"><a class="code" href="internal-masking_8h.html#ad3a968683c09d553a80dd6cfd67093ec">mask_input</a>(k2, be_load_word32(key + 8));</div>
<div class="line"><a class="code" href="internal-masking_8h.html#ad3a968683c09d553a80dd6cfd67093ec">mask_input</a>(k3, be_load_word32(key + 12));</div>
</div><!-- fragment --><p>The mask_uint32_t type contains the shares for a masked 32-bit word. The default implementation of this type has 4 shares:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div>
<div class="line">{</div>
<div class="line">    uint32_t a;</div>
<div class="line">    uint32_t b;</div>
<div class="line">    uint32_t c;</div>
<div class="line">    uint32_t d;</div>
<div class="line"></div>
<div class="line">} <a class="code" href="internal-masking_8h.html#a1bbbc6662e017843d2376226611b4e88">mask_uint32_t</a>;</div>
</div><!-- fragment --><p>The <a class="el" href="internal-masking_8h.html#ad3a968683c09d553a80dd6cfd67093ec" title="Masks an input value to produce a generic masked word. ">mask_input()</a> macro generates random material and masks the value:</p>
<div class="fragment"><div class="line">s0.<a class="code" href="structmask__x4__uint32__t.html#a4ed6d5dc6b5c0c4c54d38e0c9d152ec4">b</a> = <a class="code" href="aead-random_8h.html#a01593d6cb100e428306930561e747182">aead_random_generate_32</a>();</div>
<div class="line">s0.<a class="code" href="structmask__x4__uint32__t.html#a2a87ceaa6226fae0fb46d1f039753fe9">c</a> = <a class="code" href="aead-random_8h.html#a01593d6cb100e428306930561e747182">aead_random_generate_32</a>();</div>
<div class="line">s0.<a class="code" href="structmask__x4__uint32__t.html#abb80b057b7e8fa3e82eecee0edf061b9">d</a> = <a class="code" href="aead-random_8h.html#a01593d6cb100e428306930561e747182">aead_random_generate_32</a>();</div>
<div class="line">s0.<a class="code" href="structmask__x4__uint32__t.html#a087e10290b407a4d0f2c2991d98dcd86">a</a> = be_load_word32(input) ^ s0.<a class="code" href="structmask__x4__uint32__t.html#a4ed6d5dc6b5c0c4c54d38e0c9d152ec4">b</a> ^ s0.<a class="code" href="structmask__x4__uint32__t.html#a2a87ceaa6226fae0fb46d1f039753fe9">c</a> ^ s0.<a class="code" href="structmask__x4__uint32__t.html#abb80b057b7e8fa3e82eecee0edf061b9">d</a>;</div>
</div><!-- fragment --><p>The <a class="el" href="aead-random_8h.html#a01593d6cb100e428306930561e747182" title="Generates a single random 32-bit word. ">aead_random_generate_32()</a> function is internal to the library and generates a random 32-bit value each time it is called. Recent 32-bit ARM and other microcontrollers come with an instruction or peripheral register that provides a random 32-bit value, so obtaining random data is not hard.</p>
<p>Note: You need to call <a class="el" href="aead-random_8h.html#aabaf63ea152ee51859cb046a2740bfc7" title="Initializes the system random number generator for the generation of masking material. ">aead_random_init()</a> before any use of the masking utilities to initialize the random number source. But that can be placed into your application's startup code or your AEAD mode's setup phase.</p>
<p>The masking is repeated for the other plaintext and key words. Later, we compute the bit-sliced GIFT-128 S-box as follows:</p>
<div class="fragment"><div class="line">s1 ^= s0 &amp; s2;</div>
<div class="line">s0 ^= s1 &amp; s3;</div>
<div class="line">s2 ^= s0 | s1;</div>
<div class="line">s3 ^= s2;</div>
<div class="line">s1 ^= s3;</div>
<div class="line">s3 ^= 0xFFFFFFFFU;</div>
<div class="line">s2 ^= s0 &amp; s1;</div>
<div class="line">t = s0;</div>
<div class="line">s0 = s3;</div>
<div class="line">s3 = t;</div>
</div><!-- fragment --><p>Using the masking utilities, this becomes:</p>
<div class="fragment"><div class="line"><a class="code" href="internal-masking_8h.html#acc2be96e3a183c111f271fc8e8788570">mask_and</a>(s1, s0, s2);</div>
<div class="line"><a class="code" href="internal-masking_8h.html#acc2be96e3a183c111f271fc8e8788570">mask_and</a>(s0, s1, s3);</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a34418c16b2ac0adbd3a257edc7ae1357">mask_or</a>(s2, s0, s1);</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a1b7a772afddc428180113b50381c501c">mask_xor</a>(s3, s2);</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a1b7a772afddc428180113b50381c501c">mask_xor</a>(s1, s3);</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a3cabffba44c535617ac7f026c7323ed4">mask_not</a>(s3);</div>
<div class="line"><a class="code" href="internal-masking_8h.html#acc2be96e3a183c111f271fc8e8788570">mask_and</a>(s2, s0, s1);</div>
<div class="line"><a class="code" href="internal-masking_8h.html#aa1b68876abb10f46e1e769444ac00f86">mask_swap</a>(s0, s3);</div>
</div><!-- fragment --><p>As can be seen, the structure of the masked version of the S-box is very similar to the original, which aids in debugging the implementation during development.</p>
<p>Finally, once encryption is complete, we need to store the ciphertext to the output buffer in big-endian order:</p>
<div class="fragment"><div class="line">be_store_word32(output,      <a class="code" href="internal-masking_8h.html#a5e70933e1476f0f7e318ca8a5caec616">mask_output</a>(s0));</div>
<div class="line">be_store_word32(output + 4,  <a class="code" href="internal-masking_8h.html#a5e70933e1476f0f7e318ca8a5caec616">mask_output</a>(s1));</div>
<div class="line">be_store_word32(output + 8,  <a class="code" href="internal-masking_8h.html#a5e70933e1476f0f7e318ca8a5caec616">mask_output</a>(s2));</div>
<div class="line">be_store_word32(output + 12, <a class="code" href="internal-masking_8h.html#a5e70933e1476f0f7e318ca8a5caec616">mask_output</a>(s3));</div>
</div><!-- fragment --><p>After macro expansion, this is equivalent to:</p>
<div class="fragment"><div class="line">be_store_word32(output,      s0.<a class="code" href="structmask__x4__uint32__t.html#a087e10290b407a4d0f2c2991d98dcd86">a</a> ^ s0.<a class="code" href="structmask__x4__uint32__t.html#a4ed6d5dc6b5c0c4c54d38e0c9d152ec4">b</a> ^ s0.<a class="code" href="structmask__x4__uint32__t.html#a2a87ceaa6226fae0fb46d1f039753fe9">c</a> ^ s0.<a class="code" href="structmask__x4__uint32__t.html#abb80b057b7e8fa3e82eecee0edf061b9">d</a>);</div>
<div class="line">be_store_word32(output + 4,  s1.a ^ s1.b ^ s1.c ^ s1.d);</div>
<div class="line">be_store_word32(output + 8,  s2.a ^ s2.b ^ s2.c ^ s2.d);</div>
<div class="line">be_store_word32(output + 12, s3.a ^ s3.b ^ s3.c ^ s3.d);</div>
</div><!-- fragment --><h1><a class="anchor" id="masking_types"></a>
Types</h1>
<p>The library provides explicit types for 2, 3, 4, 5, and 6 share versions of 16-bit, 32-bit, and 64-bit words:</p>
<div class="fragment"><div class="line"><a class="code" href="structmask__x2__uint16__t.html">mask_x2_uint16_t</a></div>
<div class="line"><a class="code" href="structmask__x3__uint16__t.html">mask_x3_uint16_t</a></div>
<div class="line"><a class="code" href="structmask__x4__uint16__t.html">mask_x4_uint16_t</a></div>
<div class="line"><a class="code" href="structmask__x5__uint16__t.html">mask_x5_uint16_t</a></div>
<div class="line"><a class="code" href="structmask__x6__uint16__t.html">mask_x6_uint16_t</a></div>
<div class="line"></div>
<div class="line"><a class="code" href="structmask__x2__uint32__t.html">mask_x2_uint32_t</a></div>
<div class="line"><a class="code" href="structmask__x3__uint32__t.html">mask_x3_uint32_t</a></div>
<div class="line"><a class="code" href="structmask__x4__uint32__t.html">mask_x4_uint32_t</a></div>
<div class="line"><a class="code" href="structmask__x5__uint32__t.html">mask_x5_uint32_t</a></div>
<div class="line"><a class="code" href="structmask__x6__uint32__t.html">mask_x6_uint32_t</a></div>
<div class="line"></div>
<div class="line"><a class="code" href="structmask__x2__uint64__t.html">mask_x2_uint64_t</a></div>
<div class="line"><a class="code" href="structmask__x3__uint64__t.html">mask_x3_uint64_t</a></div>
<div class="line"><a class="code" href="structmask__x4__uint64__t.html">mask_x4_uint64_t</a></div>
<div class="line"><a class="code" href="structmask__x5__uint64__t.html">mask_x5_uint64_t</a></div>
<div class="line"><a class="code" href="structmask__x6__uint64__t.html">mask_x6_uint64_t</a></div>
</div><!-- fragment --><p>The library also contains the following generic types:</p>
<div class="fragment"><div class="line"><a class="code" href="structmask__x4__uint16__t.html">mask_uint16_t</a></div>
<div class="line"><a class="code" href="structmask__x4__uint32__t.html">mask_uint32_t</a></div>
<div class="line"><a class="code" href="structmask__x4__uint64__t.html">mask_uint64_t</a></div>
</div><!-- fragment --><p>The generic types are defined to one of the previous types based on the value of AEAD_MASKING_SHARES. For example, if the number of shares is 3, then the generic types are mapped as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="structmask__x4__uint16__t.html">mask_uint16_t</a>   =&gt;   <a class="code" href="structmask__x3__uint16__t.html">mask_x3_uint16_t</a></div>
<div class="line"><a class="code" href="structmask__x4__uint32__t.html">mask_uint32_t</a>   =&gt;   <a class="code" href="structmask__x3__uint32__t.html">mask_x3_uint32_t</a></div>
<div class="line"><a class="code" href="structmask__x4__uint64__t.html">mask_uint64_t</a>   =&gt;   <a class="code" href="structmask__x3__uint64__t.html">mask_x3_uint64_t</a></div>
</div><!-- fragment --><p>Your code can use the explicit versions if you need an exact number of shares, or you can use the generic types for the default number of shares that is specified by AEAD_MASKING_SHARES, usually 4. Using the generic types is recommended because then it is easy to recompile your code to use a different sharing ratio.</p>
<h1><a class="anchor" id="masking_operations"></a>
Operations</h1>
<p>The following generic macros are defined to assist with working with masked words. The equivalent plain C operation is shown on the right:</p>
<div class="fragment"><div class="line"><a class="code" href="internal-masking_8h.html#ad3a968683c09d553a80dd6cfd67093ec">mask_input</a>(w, x)                        w = mask(x)</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a5e70933e1476f0f7e318ca8a5caec616">mask_output</a>(w)                          return unmask(w)</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a9c5f3758568cefa5e63b1410af15e3d7">mask_xor_const</a>(w, c)                    w ^= c</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a1b7a772afddc428180113b50381c501c">mask_xor</a>(w1, w2)                        w1 ^= w2</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a79ffd997c16417059d5fc063d8e7570f">mask_xor3</a>(w1, w2, w3)                   w1 ^= (w2 ^ w3)</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a3cabffba44c535617ac7f026c7323ed4">mask_not</a>(w)                             w = ~w</div>
<div class="line"><a class="code" href="internal-masking_8h.html#acc2be96e3a183c111f271fc8e8788570">mask_and</a>(w1, w2, w3)                    w1 ^= (w2 &amp; w3)</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a868a8a20207ceeeb19a648d6da186a2e">mask_and_not</a>(w1, w2, w3)                w1 ^= ((~w2) &amp; w3)</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a34418c16b2ac0adbd3a257edc7ae1357">mask_or</a>(w1, w2, w3)                     w1 ^= (w2 | w3)</div>
<div class="line"><a class="code" href="internal-masking_8h.html#af04368f9de30227a88d96491611a0d16">mask_shl</a>(w1, w2, bits)                  w1 = (w2 &lt;&lt; bits)</div>
<div class="line"><a class="code" href="internal-masking_8h.html#acded33014d97f776d81d99512db03117">mask_shr</a>(w1, w2, bits)                  w1 = (w2 &gt;&gt; bits)</div>
<div class="line"><a class="code" href="internal-masking_8h.html#af8909fa52806835723145fc5432936e6">mask_rol</a>(w1, w2, bits)                  w1 = (w2 &lt;&lt;&lt; bits)</div>
<div class="line"><a class="code" href="internal-masking_8h.html#ad3c105e4c43ab485c472486664b5df46">mask_ror</a>(w1, w2, bits)                  w1 = (w2 &gt;&gt;&gt; bits)</div>
<div class="line"><a class="code" href="internal-masking_8h.html#aa1b68876abb10f46e1e769444ac00f86">mask_swap</a>(w1, w2)                       swaps w1 and w2</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a9e5bcbd8e1770326aba0686bce1e59a5">mask_swap_move</a>(w1, w2, mask, shift)     swaps bits in w1 and w2</div>
</div><!-- fragment --><p>These operations will work on 16-bit, 32-bit, and 64-bit masked words, adapting automatically to the underlying masked word type.</p>
<p>There are also versions of these macros for each explcit sharing ratio between 2 and 6. For example, if you wanted to force the use of the 3-share versions, you would use the following macros instead of the generic ones:</p>
<div class="fragment"><div class="line"><a class="code" href="internal-masking_8h.html#a6ec2f4a338234708cfe62a0aaba7e705">mask_x3_input</a>(w, x)                     w = mask(x)</div>
<div class="line"><a class="code" href="internal-masking_8h.html#aff94f591ebd2fc23384612ace06db980">mask_x3_output</a>(w)                       return unmask(w)</div>
<div class="line"><a class="code" href="internal-masking_8h.html#ae1e904b35edaad16128807ae7583814b">mask_x3_xor_const</a>(w, c)                 w ^= c</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a762612e1ccc1f438ddcfc1e0d62b5306">mask_x3_xor</a>(w1, w2)                     w1 ^= w2</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a6c97a6a8180cd5ff124fd00a5e8bb233">mask_x3_xor3</a>(w1, w2, w3)                w1 ^= (w2 ^ w3)</div>
<div class="line"><a class="code" href="internal-masking_8h.html#af032db8905cb06918aee34ea308d3fc8">mask_x3_not</a>(w)                          w = ~w</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a5d77b390ed885eda348012a41ae1f6cd">mask_x3_and</a>(w1, w2, w3)                 w1 ^= (w2 &amp; w3)</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a3d85a7a4f25e8530debcb3ce42544659">mask_x3_and_not</a>(w1, w2, w3)             w1 ^= ((~w2) &amp; w3)</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a13fa62dc9a0b9286abe17d23655ac40b">mask_x3_or</a>(w1, w2, w3)                  w1 ^= (w2 | w3)</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a1692714b4cb7003b3c345a2a5f6df67a">mask_x3_shl</a>(w1, w2, bits)               w1 = (w2 &lt;&lt; bits)</div>
<div class="line"><a class="code" href="internal-masking_8h.html#ab90fc5363a72998ba62ca3d0cf21d915">mask_x3_shr</a>(w1, w2, bits)               w1 = (w2 &gt;&gt; bits)</div>
<div class="line"><a class="code" href="internal-masking_8h.html#ab789bb54ac75c5cc19699c36fa9d30cd">mask_x3_rol</a>(w1, w2, bits)               w1 = (w2 &lt;&lt;&lt; bits)</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a9846ef20d7e774209ff65f06ea0c680f">mask_x3_ror</a>(w1, w2, bits)               w1 = (w2 &gt;&gt;&gt; bits)</div>
<div class="line"><a class="code" href="internal-masking_8h.html#ae68f9b9e6bcf3f2d9aab6f58d70c4e6b">mask_x3_swap</a>(w1, w2)                    swaps w1 and w2</div>
<div class="line"><a class="code" href="internal-masking_8h.html#aad6480389a9782dd61a9ef287b565cc0">mask_x3_swap_move</a>(w1, w2, mask, shift)  swaps bits in w1 and w2</div>
</div><!-- fragment --><h1><a class="anchor" id="masking_work"></a>
How do the operations work?</h1>
<p>This section provides details on how each of the operations are defined, and how that leads to an effective masked implementation. For simplicity, we will use the 3-share versions unless otherwise stated.</p>
<h2><a class="anchor" id="masking_io"></a>
Input and output</h2>
<p>The input to a cipher must be masked and converted into shares before any other operations can be performed:</p>
<div class="fragment"><div class="line">uint32_t x = ...;</div>
<div class="line"><a class="code" href="structmask__x3__uint32__t.html">mask_x3_uint32_t</a> w;</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a6ec2f4a338234708cfe62a0aaba7e705">mask_x3_input</a>(w, x);</div>
</div><!-- fragment --><p>Behind the scenes, <a class="el" href="internal-masking_8h.html#a6ec2f4a338234708cfe62a0aaba7e705" title="Masks an input value to produce a 3-share masked word. ">mask_x3_input()</a> expands to:</p>
<div class="fragment"><div class="line">w.<a class="code" href="structmask__x3__uint32__t.html#ab49d132e56c852f3c932127a014c03c4">b</a> = <a class="code" href="aead-random_8h.html#a01593d6cb100e428306930561e747182">aead_random_generate_32</a>();</div>
<div class="line">w.<a class="code" href="structmask__x3__uint32__t.html#af243b7703eaf1cfd6ff1ff74d2db6dfb">c</a> = <a class="code" href="aead-random_8h.html#a01593d6cb100e428306930561e747182">aead_random_generate_32</a>();</div>
<div class="line">w.<a class="code" href="structmask__x3__uint32__t.html#ab212db04f12a4e283869544e87d6ef97">a</a> = x ^ w.<a class="code" href="structmask__x3__uint32__t.html#ab49d132e56c852f3c932127a014c03c4">b</a> ^ w.<a class="code" href="structmask__x3__uint32__t.html#af243b7703eaf1cfd6ff1ff74d2db6dfb">c</a>;</div>
</div><!-- fragment --><p>As can be seen, masking involves generating random values for the second and subsequent shares and then XOR'ing it with the input to create the first share. After masking, the original value is no longer operative; w.a, w.b, and w.c are all randomized. For the 4-share and higher variants, more random words are generated and XOR'ed with x.</p>
<p>To recover the results at the end of the cipher, the shares are recombined using <a class="el" href="internal-masking_8h.html#aff94f591ebd2fc23384612ace06db980" title="Unmasks a 3-share masked word to produce an output value. ">mask_x3_output()</a>:</p>
<div class="fragment"><div class="line">uint32_t y = <a class="code" href="internal-masking_8h.html#aff94f591ebd2fc23384612ace06db980">mask_x3_output</a>(w);</div>
</div><!-- fragment --><p>This expands to:</p>
<div class="fragment"><div class="line">uint32_t y = w.<a class="code" href="structmask__x3__uint32__t.html#ab212db04f12a4e283869544e87d6ef97">a</a> ^ w.<a class="code" href="structmask__x3__uint32__t.html#ab49d132e56c852f3c932127a014c03c4">b</a> ^ w.<a class="code" href="structmask__x3__uint32__t.html#af243b7703eaf1cfd6ff1ff74d2db6dfb">c</a>;</div>
</div><!-- fragment --><h2><a class="anchor" id="masking_xor"></a>
XOR</h2>
<p>XOR operations are very simple. The <a class="el" href="internal-masking_8h.html#a762612e1ccc1f438ddcfc1e0d62b5306" title="XOR&#39;s two 3-share masked words. ">mask_x3_xor()</a> macro applies XOR to each of the shares individually:</p>
<div class="fragment"><div class="line"><a class="code" href="internal-masking_8h.html#a762612e1ccc1f438ddcfc1e0d62b5306">mask_x3_xor</a>(w1, w2) :</div>
<div class="line">    w1.a ^= w2.a</div>
<div class="line">    w1.b ^= w2.b</div>
<div class="line">    w1.c ^= w2.c</div>
</div><!-- fragment --><p>Things are slightly different when XOR'ing round constants into a masked word:</p>
<div class="fragment"><div class="line"><a class="code" href="internal-masking_8h.html#ae1e904b35edaad16128807ae7583814b">mask_x3_xor_const</a>(w, c) :</div>
<div class="line">    w.a ^= c</div>
</div><!-- fragment --><p>Here, only the first share in the masked word is updated. The rest of the shares are left as-is. To show why we only update the first share, let's see what happens with the 2-share version if we were to XOR the constant with all shares instead of just the first:</p>
<div class="fragment"><div class="line"><a class="code" href="internal-masking_8h.html#a67cc243391d4b2c6e061cc42da7767bf">mask_x2_input</a>(w, x) :</div>
<div class="line">    w.b = rand</div>
<div class="line">    w.a = x ^ w.b</div>
<div class="line"></div>
<div class="line"><a class="code" href="internal-masking_8h.html#af06854a35ed3081aa189aecbdefd3740">mask_x2_xor_const</a>(w, c) :</div>
<div class="line">    w.a ^= c</div>
<div class="line">    w.b ^= c</div>
<div class="line"></div>
<div class="line">y = <a class="code" href="internal-masking_8h.html#a387a824d610694908bde1cd560fc360d">mask_x2_output</a>(w) :</div>
<div class="line">    y = w.a ^ w.b</div>
<div class="line">      = (x ^ rand ^ c) ^ (rand ^ c)</div>
<div class="line">      = x</div>
</div><!-- fragment --><p>We expected "x ^ c" at the end, not x. The constant cancelled itself out when the final state was unmasked. If we only XOR the round constant into the first share, we get:</p>
<div class="fragment"><div class="line"><a class="code" href="internal-masking_8h.html#a67cc243391d4b2c6e061cc42da7767bf">mask_x2_input</a>(w, x) :</div>
<div class="line">    w.b = rand</div>
<div class="line">    w.a = x ^ w.b</div>
<div class="line"></div>
<div class="line"><a class="code" href="internal-masking_8h.html#af06854a35ed3081aa189aecbdefd3740">mask_x2_xor_const</a>(w, c) :</div>
<div class="line">    w.a ^= c</div>
<div class="line"></div>
<div class="line">y = <a class="code" href="internal-masking_8h.html#a387a824d610694908bde1cd560fc360d">mask_x2_output</a>(w) :</div>
<div class="line">    y = w.a ^ w.b</div>
<div class="line">      = (x ^ rand ^ c) ^ rand</div>
<div class="line">      = x ^ c</div>
</div><!-- fragment --><p>This gives us the result we wanted.</p>
<p>Finally, <a class="el" href="internal-masking_8h.html#a79ffd997c16417059d5fc063d8e7570f" title="XOR&#39;s three generic masked words. ">mask_xor3()</a> can be used to XOR three masked words together:</p>
<div class="fragment"><div class="line"><a class="code" href="internal-masking_8h.html#a6c97a6a8180cd5ff124fd00a5e8bb233">mask_x3_xor3</a>(w1, w2, w3) :</div>
<div class="line">    w1.a ^= (w2.a ^ w3.a)</div>
<div class="line">    w1.b ^= (w2.b ^ w3.b)</div>
<div class="line">    w1.c ^= (w2.c ^ w3.c)</div>
</div><!-- fragment --><p>The 3-word version of XOR can be more efficient than two separate calls to <a class="el" href="internal-masking_8h.html#a1b7a772afddc428180113b50381c501c" title="XOR&#39;s two generic masked words. ">mask_xor()</a> because the intermediate values for each share can be kept in registers longer.</p>
<h2><a class="anchor" id="masking_not"></a>
NOT</h2>
<p>NOT operations are a special case of XOR'ing with the all-1's round constant. The following are equivalent for 32-bit masked words:</p>
<div class="fragment"><div class="line"><a class="code" href="internal-masking_8h.html#af032db8905cb06918aee34ea308d3fc8">mask_x3_not</a>(w);</div>
<div class="line"><a class="code" href="internal-masking_8h.html#ae1e904b35edaad16128807ae7583814b">mask_x3_xor_const</a>(w, 0xFFFFFFFF);</div>
</div><!-- fragment --><p>The <a class="el" href="internal-masking_8h.html#af032db8905cb06918aee34ea308d3fc8" title="NOT&#39;s a 3-share masked word. ">mask_x3_not()</a> function is more convenient because it works on 16-bit, 32-bit, and 64-bit words without the programmer having to supply an all-1's constant of the right size.</p>
<p>Let's expand <a class="el" href="internal-masking_8h.html#af032db8905cb06918aee34ea308d3fc8" title="NOT&#39;s a 3-share masked word. ">mask_x3_not()</a> and see what it is doing:</p>
<div class="fragment"><div class="line"><a class="code" href="internal-masking_8h.html#a6ec2f4a338234708cfe62a0aaba7e705">mask_x3_input</a>(w, x) :</div>
<div class="line">    w.b = rand1</div>
<div class="line">    w.c = rand2</div>
<div class="line">    w.a = x ^ w.b ^ w.c</div>
<div class="line"></div>
<div class="line"><a class="code" href="internal-masking_8h.html#af032db8905cb06918aee34ea308d3fc8">mask_x3_not</a>(w) :</div>
<div class="line">    w.a = ~w.a</div>
<div class="line"></div>
<div class="line">y = <a class="code" href="internal-masking_8h.html#aff94f591ebd2fc23384612ace06db980">mask_x3_output</a>(w) :</div>
<div class="line">    y = w.a ^ w.b ^ w.c</div>
<div class="line">      = ~(x ^ rand1 ^ rand2) ^ rand1 ^ rand2</div>
<div class="line">      = (~x) ^ rand1 ^ rand2 ^ rand1 ^ rand2</div>
<div class="line">      = ~x</div>
</div><!-- fragment --><h2><a class="anchor" id="masking_and"></a>
AND</h2>
<p>The AND operation is the most complex of the masked operations. Here is the 4-share version:</p>
<div class="fragment"><div class="line"><a class="code" href="internal-masking_8h.html#aff217fc78afb4c4e03f967d479309ff8">mask_x4_and</a>(w1, w2, w3) :</div>
<div class="line">    w1.a ^= (w2.a &amp; w3.a)</div>
<div class="line">    mix(w1.a, w2.a, w3.a, w1.b, w2.b, w3.b)</div>
<div class="line">    mix(w1.a, w2.a, w3.a, w1.c, w2.c, w3.c)</div>
<div class="line">    mix(w1.a, w2.a, w3.a, w1.d, w2.d, w3.d)</div>
<div class="line">    w1.b ^= (w2.b &amp; w3.b)</div>
<div class="line">    mix(w1.b, w2.b, w3.b, w1.c, w2.c, w3.c)</div>
<div class="line">    mix(w1.b, w2.b, w3.b, w1.d, w2.d, w3.d)</div>
<div class="line">    w1.c ^= (w2.c &amp; w3.c)</div>
<div class="line">    mix(w1.c, w2.c, w3.c, w1.d, w2.d, w3.d)</div>
<div class="line">    w1.d ^= (w2.d &amp; w3.d)</div>
<div class="line"></div>
<div class="line">mix(a1, a2, a3, b1, b2, b3) :</div>
<div class="line">    temp = <a class="code" href="aead-random_8h.html#a01593d6cb100e428306930561e747182">aead_random_generate_32</a>()</div>
<div class="line">    a1 ^= temp</div>
<div class="line">    b1 ^= temp ^ (b3 &amp; a2) ^ (b2 &amp; a3)</div>
</div><!-- fragment --><p>Essentially this is performing a diagonal matrix operation where each share is mixed with all of the shares below it and to the right. At each step, a new random number is generated and mixed into the state.</p>
<p>Note: The <a class="el" href="internal-masking_8h.html#acc2be96e3a183c111f271fc8e8788570" title="AND&#39;s two generic masked words and XOR&#39;s the result with another word. ">mask_and()</a>, <a class="el" href="internal-masking_8h.html#a868a8a20207ceeeb19a648d6da186a2e" title="AND&#39;s two generic masked words and XOR&#39;s the result with another word, where the first input word is ...">mask_and_not()</a>, and <a class="el" href="internal-masking_8h.html#a34418c16b2ac0adbd3a257edc7ae1357" title="OR&#39;s two generic masked words and XOR&#39;s the result with another word. ">mask_or()</a> macros require a local variable called "temp" in the current scope that is of type uint16_t, uint32_t, or uint64_t depending upon the type of masked word you are operating on.</p>
<p>For a masked word with N shares, each AND operation requires (N² - N) / 2 random number generator calls and mix operations. This has a significant impact on performance compared with the non-masked version of AND. The higher the number of shares, or the higher the number of AND operations, the slower the masked cipher will become.</p>
<h2><a class="anchor" id="masking_and_not"></a>
AND-NOT</h2>
<p>A common variant of AND is to invert the first argument. For example, here is step chi of Xoodoo:</p>
<div class="fragment"><div class="line">x00 ^= (~x10) &amp; x20;</div>
<div class="line">x10 ^= (~x20) &amp; x00;</div>
<div class="line">x20 ^= (~x00) &amp; x10;</div>
<div class="line">x01 ^= (~x11) &amp; x21;</div>
<div class="line">x11 ^= (~x21) &amp; x01;</div>
<div class="line">x21 ^= (~x01) &amp; x11;</div>
<div class="line">x02 ^= (~x12) &amp; x22;</div>
<div class="line">x12 ^= (~x22) &amp; x02;</div>
<div class="line">x22 ^= (~x02) &amp; x12;</div>
<div class="line">x03 ^= (~x13) &amp; x23;</div>
<div class="line">x13 ^= (~x23) &amp; x03;</div>
<div class="line">x23 ^= (~x03) &amp; x13;</div>
</div><!-- fragment --><p>While it is possible to create temporaries to hold the NOT-inverted intermediate values, it is easier and more memory-efficient to use <a class="el" href="internal-masking_8h.html#a868a8a20207ceeeb19a648d6da186a2e" title="AND&#39;s two generic masked words and XOR&#39;s the result with another word, where the first input word is ...">mask_and_not()</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="internal-masking_8h.html#a868a8a20207ceeeb19a648d6da186a2e">mask_and_not</a>(x00, x10, x20);</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a868a8a20207ceeeb19a648d6da186a2e">mask_and_not</a>(x10, x20, x00);</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a868a8a20207ceeeb19a648d6da186a2e">mask_and_not</a>(x20, x00, x10);</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a868a8a20207ceeeb19a648d6da186a2e">mask_and_not</a>(x01, x11, x21);</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a868a8a20207ceeeb19a648d6da186a2e">mask_and_not</a>(x11, x21, x01);</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a868a8a20207ceeeb19a648d6da186a2e">mask_and_not</a>(x21, x01, x11);</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a868a8a20207ceeeb19a648d6da186a2e">mask_and_not</a>(x02, x12, x22);</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a868a8a20207ceeeb19a648d6da186a2e">mask_and_not</a>(x12, x22, x02);</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a868a8a20207ceeeb19a648d6da186a2e">mask_and_not</a>(x22, x02, x12);</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a868a8a20207ceeeb19a648d6da186a2e">mask_and_not</a>(x03, x13, x23);</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a868a8a20207ceeeb19a648d6da186a2e">mask_and_not</a>(x13, x23, x03);</div>
<div class="line"><a class="code" href="internal-masking_8h.html#a868a8a20207ceeeb19a648d6da186a2e">mask_and_not</a>(x23, x03, x13);</div>
</div><!-- fragment --><h2><a class="anchor" id="masking_or"></a>
OR</h2>
<p>The OR operation is implemented in terms of AND using DeMorgan's Law: (A | B) = ~(~(A) &amp; ~(B)). The 4-share version of OR is:</p>
<div class="fragment"><div class="line"><a class="code" href="internal-masking_8h.html#a5bbca4508e5efe03ff2ab5504df42be1">mask_x4_or</a>(w1, w2, w3) :</div>
<div class="line">    w1.a ^= (w2.a | w3.a)</div>
<div class="line">    mix(w1.a, ~w2.a, ~w3.a, w1.b, w2.b, w3.b)</div>
<div class="line">    mix(w1.a, ~w2.a, ~w3.a, w1.c, w2.c, w3.c)</div>
<div class="line">    mix(w1.a, ~w2.a, ~w3.a, w1.d, w2.d, w3.d)</div>
<div class="line">    w1.b ^= (w2.b &amp; w3.b)</div>
<div class="line">    mix(w1.b, w2.b, w3.b, w1.c, w2.c, w3.c)</div>
<div class="line">    mix(w1.b, w2.b, w3.b, w1.d, w2.d, w3.d)</div>
<div class="line">    w1.c ^= (w2.c &amp; w3.c)</div>
<div class="line">    mix(w1.c, w2.c, w3.c, w1.d, w2.d, w3.d)</div>
<div class="line">    w1.d ^= (w2.d &amp; w3.d)</div>
</div><!-- fragment --><p>As mentioned previously, the NOT operation only affects the first share, so only some of the terms need to be inverted to convert OR into AND.</p>
<h2><a class="anchor" id="masking_rotates"></a>
Shift and rotate</h2>
<p>The <a class="el" href="internal-masking_8h.html#a1692714b4cb7003b3c345a2a5f6df67a" title="Performs a left shift on a 3-share masked word. ">mask_x3_shl()</a>, <a class="el" href="internal-masking_8h.html#ab90fc5363a72998ba62ca3d0cf21d915" title="Performs a right shift on a 3-share masked word. ">mask_x3_shr()</a>, <a class="el" href="internal-masking_8h.html#ab789bb54ac75c5cc19699c36fa9d30cd" title="Performs a left rotate on a 3-share masked word. ">mask_x3_rol()</a>, and <a class="el" href="internal-masking_8h.html#a9846ef20d7e774209ff65f06ea0c680f" title="Performs a right rotate on a 3-share masked word. ">mask_x3_ror()</a> functions perform a left shift, right shift, left rotate, and right rotate respectively. Like <a class="el" href="internal-masking_8h.html#a762612e1ccc1f438ddcfc1e0d62b5306" title="XOR&#39;s two 3-share masked words. ">mask_x3_xor()</a>, they operate on each share individually.</p>
<div class="fragment"><div class="line"><a class="code" href="internal-masking_8h.html#a1692714b4cb7003b3c345a2a5f6df67a">mask_x3_shl</a>(w1, w2, bits) :</div>
<div class="line">    w1.a = (w2.a &lt;&lt; bits)</div>
<div class="line">    w1.b = (w2.b &lt;&lt; bits)</div>
<div class="line">    w1.c = (w2.c &lt;&lt; bits)</div>
</div><!-- fragment --><p>The first two arguments can be the same masked word for in-place shift and rotate operations:</p>
<div class="fragment"><div class="line"><a class="code" href="internal-masking_8h.html#a1692714b4cb7003b3c345a2a5f6df67a">mask_x3_shl</a>(w, w, bits) :</div>
<div class="line">    w.a &lt;&lt;= bits</div>
<div class="line">    w.b &lt;&lt;= bits</div>
<div class="line">    w.c &lt;&lt;= bits</div>
</div><!-- fragment --><h2><a class="anchor" id="masking_swap"></a>
Swap</h2>
<p>The <a class="el" href="internal-masking_8h.html#aa1b68876abb10f46e1e769444ac00f86" title="Performs a swap on two generic masked words. ">mask_swap()</a> function swaps two masked words and the <a class="el" href="internal-masking_8h.html#a9e5bcbd8e1770326aba0686bce1e59a5" title="Performs a swap and move on two generic masked words. ">mask_swap_move()</a> function performs a swap on some of the bits in two masked words. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 14 2020 15:29:35 for Lightweight Cryptography Primitives by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
