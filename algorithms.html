<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Lightweight Cryptography Primitives: Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Lightweight Cryptography Primitives
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Algorithms </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#alg_which_one">Which algorithm should I use?</a></li>
<li class="level1"><a href="#alg_no_aes">Notes on algorithms that use AES</a></li>
<li class="level1"><a href="#alg_nonces">Notes on AEAD algorithms and nonces</a></li>
<li class="level1"><a href="#alg_bugs">Bugs</a></li>
<li class="level1"><a href="#alg_properties">Summary</a></li>
<li class="level1"><a href="#alg_side_channels">Algorithms with side channel protection</a></li>
<li class="level1"><a href="#alg_ace">ACE</a></li>
<li class="level1"><a href="#alg_ascon">ASCON</a></li>
<li class="level1"><a href="#alg_comet">COMET</a></li>
<li class="level1"><a href="#alg_drygascon">DryGASCON</a></li>
<li class="level1"><a href="#alg_elephant">Elephant</a></li>
<li class="level1"><a href="#alg_estate">ESTATE</a></li>
<li class="level1"><a href="#alg_forkae">ForkAE</a></li>
<li class="level1"><a href="#alg_gift_cofb">GIFT-COFB</a></li>
<li class="level1"><a href="#alg_gimli">Gimli</a></li>
<li class="level1"><a href="#alg_grain_128aead">Grain-128AEAD</a></li>
<li class="level1"><a href="#alg_hyena">HYENA</a></li>
<li class="level1"><a href="#alg_isap">ISAP</a></li>
<li class="level1"><a href="#alg_knot">KNOT</a></li>
<li class="level1"><a href="#alg_lotus">LOTUS-AEAD and LOCUS-AEAD</a></li>
<li class="level1"><a href="#alg_mixfeed">mixFeed</a></li>
<li class="level1"><a href="#alg_orange">ORANGE</a></li>
<li class="level1"><a href="#alg_oribatida">Oribatida</a></li>
<li class="level1"><a href="#alg_photon_beetle">PHOTON-Beetle</a></li>
<li class="level1"><a href="#alg_pyjamask">Pyjamask</a></li>
<li class="level1"><a href="#alg_romulus">Romulus</a></li>
<li class="level1"><a href="#alg_saeaes">SAEAES</a></li>
<li class="level1"><a href="#alg_saturnin">Saturnin</a></li>
<li class="level1"><a href="#alg_skinny_aead">SKINNY-AEAD</a></li>
<li class="level1"><a href="#alg_sparkle">SPARKLE</a></li>
<li class="level1"><a href="#alg_spix">SPIX</a></li>
<li class="level1"><a href="#alg_spoc">SpoC</a></li>
<li class="level1"><a href="#alg_spook">Spook</a></li>
<li class="level1"><a href="#alg_subterranean">Subterranean</a></li>
<li class="level1"><a href="#alg_sundae_gift">SUNDAE-GIFT</a></li>
<li class="level1"><a href="#alg_tinyjambu">TinyJAMBU</a></li>
<li class="level1"><a href="#alg_wage">WAGE</a></li>
<li class="level1"><a href="#alg_xoodyak">Xoodyak</a></li>
<li class="level1"><a href="#alg_internal">Internal block operations</a></li>
</ul>
</div>
<div class="textblock"><p>This page lists all of the submissions to the second round of the <a href="https://csrc.nist.gov/projects/lightweight-cryptography/round-2-candidates">NIST Lightweight Cryptography Competition</a> and the degree of support for each algorithm in the library.</p>
<h1><a class="anchor" id="alg_which_one"></a>
Which algorithm should I use?</h1>
<p>This is a tough question given that as of early-2020 the NIST competition has not yet whittled the list down or decided on final candidates. But if you want to get encrypting now:</p>
<ul>
<li><a class="el" href="algorithms.html#alg_ascon">ASCON-128</a> was already selected as a finalist for the <a href="https://competitions.cr.yp.to/caesar-submissions.html">CAESAR AEAD competition</a> (128-bit key). </li>
<li><a class="el" href="algorithms.html#alg_gimli">Gimli</a> is the spiritual successor to the widely used ChaCha20 and has a similar design (256-bit key). </li>
<li><a class="el" href="algorithms.html#alg_comet">COMET-128_CHAM-128/128</a> is currently the fastest algorithm in the library in terms of raw performance (128-bit key). </li>
<li><a class="el" href="algorithms.html#alg_tinyjambu">TinyJAMBU-128</a> has comparable performance to GIMLI-24 with a small RAM and flash memory footprint (128-bit key, with options for 192-bit and 256-bit keys as well). </li>
<li>(others may be added here as I implement more algorithms)</li>
</ul>
<p>Note that these are my own personal preferences and are not based on any in-depth security analysis. The above algorithms could fall to an attack tomorrow but for now they have good space and speed trade-offs when implemented in software on 32-bit platforms.</p>
<h1><a class="anchor" id="alg_no_aes"></a>
Notes on algorithms that use AES</h1>
<p>Some of the submissions to NIST use AES as the inner block cipher in the AEAD implementation. I haven't implemented any of those algorithms. AES is notoriously difficult to implement in software in a manner that avoids cache timing attacks. It is best to ignore AES and do something else.</p>
<p>From a high level point of view, if AES is already suitable as a lightweight cipher, then there's really no point to the NIST competition. The most the competition can produce is a new block cipher mode, and that mode could just as easily be used with a different block cipher that is not subject to cache timing attacks.</p>
<h1><a class="anchor" id="alg_nonces"></a>
Notes on AEAD algorithms and nonces</h1>
<p>Every submission to the NIST competition takes the form of an Authenticated Encryption with Associated Data (AEAD) scheme. Such schemes typically take as input a key and a packet-specific nonce to encrypt a given plaintext and to authenticate the ciphertext plus some associated data (AD) that is not encrypted.</p>
<p>In the documentation for most AEAD schemes you will prominently find a prescription that "The nonce must be unique for every packet.  If it isn't,
then the scheme is not secure". Beginners to encryption can sometimes overlook this and not take sufficient care to make the nonce unique (usually a constantly-incrementing packet sequence number is sufficient).</p>
<p>To demonstrate why nonce reuse is bad, I'll briefly describe how AES-GCM works as it is typical of AEAD schemes:</p>
<ul>
<li>Generate a key stream KS from the Key and Nonce using AES in counter mode where the nonce is used as the high-order bits of the counter. In other words, KS = AES-CTR-STREAM(Key, Nonce). </li>
<li>XOR KS with the plaintext to produce the ciphertext. </li>
<li>Run the GCM authenticator over the associated data and ciphertext to produce the authentication tag.</li>
</ul>
<p>Now let's see what happens when we reuse the nonce. We will have two packets with the same keystream:</p>
<ul>
<li>Ciphertext1 = Plaintext1 XOR KS </li>
<li>Ciphertext2 = Plaintext2 XOR KS</li>
</ul>
<p>If an attacker was able to guess Plaintext1 because it is a standard protocol header or similar, then they can trivially determine the keystream and the other plaintext with:</p>
<ul>
<li>KS = Ciphertext1 XOR Guessed-Plaintext1 </li>
<li>Plaintext2 = Ciphertext2 XOR KS</li>
</ul>
<p>This is why it is so important that the nonce be unique for every packet. It is trivial to break many AEAD schemes if the nonce is chosen poorly.</p>
<p>Not all AEAD schemes are as vulnerable to nonce reuse. SUNDAE-GIFT has a variant with a zero-length nonce! The SUNDAE-GIFT specification states that as long as the combination (AD, Plaintext) is unique for each packet, then there is no need for a nonce: the associated data AD acts like a nonce. But obviously you still need to be careful to make the combination (AD, Plaintext) unique!</p>
<p>Below we will state any special considerations if the algorithm is resistant against nonce reuse. In the absence of any special considerations, you should assume that changing the nonce for each packet is vital for security.</p>
<h1><a class="anchor" id="alg_bugs"></a>
Bugs</h1>
<p>A few bugs were found in the reference code for some of the algorithms. The bugs and their fixes are documented on <a class="el" href="bugs.html">this page</a>.</p>
<h1><a class="anchor" id="alg_properties"></a>
Summary</h1>
<p>The following table summarises the interesting properties of all (non-AES) NIST submissions. More details are provided in the sections below.</p>
<table class="doxtable">
<tr>
<td>Algorithm</td><td>Key Sizes</td><td>Core</td><td>Mode</td><td>Inverse Free</td><td>Nonce Reuse</td><td>Side Channels</td><td>Post Quantum</td><td>Hashing </td></tr>
<tr>
<td>ACE</td><td>128</td><td>ACE</td><td>ACE</td><td></td><td></td><td></td><td></td><td>Digest </td></tr>
<tr>
<td>ASCON</td><td>128/160</td><td>ASCON</td><td>MonkeyDuplex</td><td></td><td></td><td></td><td>K</td><td>Digest/XOF </td></tr>
<tr>
<td>COMET</td><td>128</td><td>CHAM-128/CHAM-64/SPECK-64</td><td>CTR/Beetle</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>DryGASCON</td><td>128/256</td><td>GASCON</td><td>DryGASCON</td><td></td><td></td><td>Y</td><td>K</td><td>Digest </td></tr>
<tr>
<td>Elephant</td><td>128</td><td>Spongent/Keccak</td><td>Elephant</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>ESTATE</td><td>128</td><td>GIFT-128</td><td>FCBC/OFB</td><td></td><td>Y</td><td></td><td></td><td></td></tr>
<tr>
<td>ForkAE</td><td>128</td><td>ForkSkinny</td><td>PAEF/SAEF</td><td>N</td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>GIFT-COFB</td><td>128</td><td>GIFT-128</td><td>COFB</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>Gimli</td><td>256</td><td>Gimli</td><td>Duplex</td><td></td><td></td><td></td><td>Y</td><td>Digest/XOF </td></tr>
<tr>
<td>Grain-128AEAD</td><td>128</td><td>Grain-128</td><td>Grain-128AEAD</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>HYENA</td><td>128</td><td>GIFT-128</td><td>HyFB</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>ISAP</td><td>128</td><td>ASCON/Keccak</td><td>Duplex</td><td></td><td></td><td>Y</td><td></td><td></td></tr>
<tr>
<td>KNOT</td><td>128/192/256</td><td>KNOT</td><td>MonkeyDuplex</td><td></td><td></td><td></td><td>K</td><td>Digest </td></tr>
<tr>
<td>LOTUS-AEAD</td><td>128</td><td>GIFT-64</td><td>OTR</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>LOCUS-AEAD</td><td>128</td><td>GIFT-64</td><td>OCB</td><td>N</td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>ORANGE</td><td>128</td><td>PHOTON-256</td><td>ORANGE</td><td></td><td></td><td></td><td></td><td>Digest </td></tr>
<tr>
<td>Oribatida</td><td>128</td><td>SimP</td><td>Masked Duplex</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>PHOTON-Beetle</td><td>128</td><td>PHOTON-256</td><td>Beetle</td><td></td><td></td><td></td><td></td><td>Digest </td></tr>
<tr>
<td>Pyjamask</td><td>128</td><td>Pyjamask-128/Pyjamask-96</td><td>OCB</td><td>N</td><td></td><td>M</td><td></td><td></td></tr>
<tr>
<td>Romulus-N</td><td>128</td><td>SKINNY-128</td><td>Romulus-N</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>Romulus-M</td><td>128</td><td>SKINNY-128</td><td>Romulus-M</td><td></td><td>Y</td><td></td><td></td><td></td></tr>
<tr>
<td>Saturnin</td><td>256</td><td>Saturnin</td><td>CTR/Cascade</td><td></td><td></td><td></td><td>Y</td><td>Digest </td></tr>
<tr>
<td>Saturnin-Short</td><td>256</td><td>Saturnin</td><td>ECB</td><td>N</td><td></td><td></td><td>Y</td><td></td></tr>
<tr>
<td>SKINNY-AEAD</td><td>128</td><td>SKINNY-128</td><td>ΘCB3</td><td>N</td><td></td><td></td><td></td><td>Digest </td></tr>
<tr>
<td>SPARKLE</td><td>128/192/256</td><td>SPARKLE</td><td>Beetle</td><td></td><td></td><td></td><td>K</td><td>Digest </td></tr>
<tr>
<td>SPIX</td><td>128</td><td>sLiSCP-light-256</td><td>MonkeyDuplex</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>SpoC</td><td>128</td><td>sLiSCP-light-256/192</td><td>SpoC</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>Spook</td><td>128</td><td>Clyde-128/Shadow</td><td>S1P</td><td></td><td>Y</td><td>M</td><td></td><td></td></tr>
<tr>
<td>Subterranean</td><td>128</td><td>Subterranean</td><td>Duplex</td><td></td><td></td><td></td><td></td><td>Digest </td></tr>
<tr>
<td>SUNDAE-GIFT</td><td>128</td><td>GIFT-128</td><td>SUNDAE</td><td></td><td>Y</td><td></td><td></td><td></td></tr>
<tr>
<td>TinyJAMBU</td><td>128/192/256</td><td>TinyJAMBU</td><td>TinyJAMBU</td><td></td><td></td><td></td><td>K</td><td></td></tr>
<tr>
<td>WAGE</td><td>128</td><td>WAGE</td><td>Duplex</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>Xoodyak</td><td>128</td><td>Xoodoo</td><td>Cyclist</td><td></td><td></td><td>R</td><td></td><td>Digest/XOF </td></tr>
</table>
<p>"Core" indicates the core block operation that the sponge or block cipher mode is built around, and "Mode" indicates the mode itself.</p>
<p>"Inverse Free" is "N" to indicate that the core block operation is used in both the encryption and decryption directions, or blank if the AEAD mode only needs encryption.</p>
<p>"Nonce Reuse" indicates that the algorithm provides some resistance against nonce reuse.</p>
<p>"Side Channels" indicates that the algorithm provides some resistance against power analysis side channels: "Y" indicates that the resistance is built in, "M" indicates that the resistance is present only if the core block operation is masked, and "R" indicates that the resistance is present only if the cipher is rekeyed after every packet.</p>
<p>"Post Quantum" indicates if the algorithm has resistance against post-quantum adversaries: "Y" indicates that all key sizes are resistant, "K" indicates that key sizes larger than 128 bits (e.g. 160, 192, or 256) provide the post-quantum resistance.</p>
<h1><a class="anchor" id="alg_side_channels"></a>
Algorithms with side channel protection</h1>
<p>The following algorithm implementations in this library attempt to provide some protection against power analysis side channels:</p>
<ul>
<li><a class="el" href="algorithms.html#alg_ascon">ASCON</a> </li>
<li><a class="el" href="algorithms.html#alg_drygascon">DryGASCON</a> </li>
<li><a class="el" href="algorithms.html#alg_gift_cofb">GIFT-COFB</a> version) </li>
<li><a class="el" href="algorithms.html#alg_gimli">Gimli</a> </li>
<li><a class="el" href="algorithms.html#alg_isap">ISAP</a> </li>
<li><a class="el" href="algorithms.html#alg_knot">KNOT</a> </li>
<li><a class="el" href="algorithms.html#alg_pyjamask">Pyjamask</a> </li>
<li><a class="el" href="algorithms.html#alg_spix">SPIX</a> </li>
<li><a class="el" href="algorithms.html#alg_spoc">SpoC</a> </li>
<li><a class="el" href="algorithms.html#alg_spook">Spook</a> </li>
<li><a class="el" href="algorithms.html#alg_tinyjambu">TinyJAMBU</a> </li>
<li><a class="el" href="algorithms.html#alg_xoodyak">Xoodyak</a></li>
</ul>
<p>These implementations have not yet been subjected to rigorous analysis, so the level of protection may not be as great as hoped.</p>
<p>In the case of DryGASCON and ISAP, the protection is built into the algorithm. For the others, the "individual" directory contains "*_masked" variants side by side with the original unprotected versions.</p>
<h1><a class="anchor" id="alg_ace"></a>
ACE</h1>
<p><b>Definition:</b> <a class="el" href="ace_8h.html">ace.h</a></p>
<p>ACE is an authenticated encryption algorithm with a 128-bit key, a 128-bit nonce, and a 128-bit tag. It uses a duplex construction on top of a 320-bit permutation. The permutation is a generalised version of sLiSCP-light, extended from 256 bits to 320 bits. ACE also has a companion hash algorithm with a 256-bit output.</p>
<p><b>Similar Algorithms:</b> <a class="el" href="algorithms.html#alg_spix">SPIX</a>, <a class="el" href="algorithms.html#alg_spoc">SpoC</a></p>
<h1><a class="anchor" id="alg_ascon"></a>
ASCON</h1>
<p><b>Definition:</b> <a class="el" href="ascon128_8h.html">ascon128.h</a></p>
<p>The ASCON family consists of the following AEAD algorithms:</p>
<ul>
<li>ASCON-128 with a 128-bit key, a 128-bit nonce, and a 128-bit tag. </li>
<li>ASCON-128-a with a 128-bit key, a 128-bit nonce, and a 128-bit tag. </li>
<li>ASCON-80pq with a 160-bit key, a 128-bit nonce, and a 128-bit tag.</li>
</ul>
<p>ASCON-128 is the recommended algorithm from the NIST submission. ASCON-128-a is faster but does not mix the input state quite as much as ASCON-128. ASCON-80pq is essentially the same as ASCON-128 but it has a 160-bit key which may give added resistance against quantum computers.</p>
<p>The library also implements the ASCON-HASH and ASCON-XOF hashing algorithms as companions to the AEAD mode.</p>
<p>This library also provides a masked implementation of ASCON.</p>
<p><b>Recommendation:</b> Use ASCON-128 for now unless you consider the 128-bit key length to be too short, in which case you should use ASCON-80pq.</p>
<h1><a class="anchor" id="alg_comet"></a>
COMET</h1>
<p><b>Definition:</b> <a class="el" href="comet_8h.html">comet.h</a></p>
<p>COMET is a family of authenticated encryption algorithms that are built around an underlying block cipher. This library implements three members of the family:</p>
<ul>
<li>COMET-128_CHAM-128/128 which has a 128-bit key, a 128-bit nonce, and a 128-bit tag, built around the CHAM-128/128 block cipher. </li>
<li>COMET-64_CHAM-64/128 which has a 128-bit key, a 120-bit nonce, and a 64-bit tag, built around the CHAM-64/128 block cipher. </li>
<li>COMET-64_SPECK-64/128 which has a 128-bit key, a 120-bit nonce, and a 64-bit tag, built around the SPECK-64/128 block cipher.</li>
</ul>
<p>There is also another family member COMET-128_AES-128/128 that is built around AES but this library does not implement that version.</p>
<p>COMET-128_CHAM-128/128 has good performance in software on 32-bit platforms.</p>
<p><b>Recommendation:</b> The specification recommends COMET-128_AES-128/128 but we don't implement AES-based schemes in this library. Recommend to use COMET-128_CHAM-128/128 instead.</p>
<h1><a class="anchor" id="alg_drygascon"></a>
DryGASCON</h1>
<p><b>Definition:</b> <a class="el" href="drygascon_8h.html">drygascon.h</a></p>
<p>DryGASCON is a family of authenticated encryption algorithms based around a generalised version of the ASCON permutation. DryGASCON is designed to provide some protection against power analysis.</p>
<p>There are four algorithms in the DryGASCON family:</p>
<ul>
<li>DryGASCON128 is an authenticated encryption algorithm with a 128-bit key, a 128-bit nonce, and a 128-bit authentication tag. </li>
<li>DryGASCON256 is an authenticated encryption algorithm with a 256-bit key, a 128-bit nonce, and a 128-256 authentication tag. </li>
<li>DryGASCON128-HASH is a hash algorithm with a 256-bit output. </li>
<li>DryGASCON256-HASH is a hash algorithm with a 512-bit output.</li>
</ul>
<p><b>Recommendation:</b> The specification recommends DryGASCON128 and DryGASCON128-HASH.</p>
<h1><a class="anchor" id="alg_elephant"></a>
Elephant</h1>
<p><b>Definition:</b> <a class="el" href="elephant_8h.html">elephant.h</a></p>
<p>Elephant is a family of authenticated encryption algorithms based around the Spongent-pi and Keccak permutations.</p>
<ul>
<li>Dumbo has a 128-bit key, a 96-bit nonce, and a 64-bit authentication tag. It is based around the Spongent-pi[160] permutation. </li>
<li>Jumbo has a 128-bit key, a 96-bit nonce, and a 64-bit authentication tag. It is based around the Spongent-pi[176] permutation. </li>
<li>Delirium has a 128-bit key, a 96-bit nonce, and a 128-bit authentication tag. It is based around the Keccak[200] permutation.</li>
</ul>
<p><b>Recommendation:</b> The specification recommends Dumbo.</p>
<h1><a class="anchor" id="alg_estate"></a>
ESTATE</h1>
<p><b>Definition:</b> <a class="el" href="estate_8h.html">estate.h</a></p>
<p><b>Nonce Reuse:</b> Resistant against nonce reuse as long as the combination of the associated data (AD) and plaintext is unique.</p>
<p>ESTATE_TweGIFT-128 is an authenticated encryption algorithm with a 128-bit key, a 128-bit nonce, and a 128-bit tag. It is a two-pass algorithm that is built around a tweaked version of the GIFT-128 block cipher, the FCBC authentication mode, and the OFB encryption mode.</p>
<p>ESTATE is resistant against nonce reuse as long as the combination of the associated data and plaintext is unique.</p>
<p>If a nonce is reused then two packets with the same nonce, associated data, and plaintext will encrypt to the same ciphertext. This will leak that the same plaintext has been sent for a second time but will not reveal the plaintext itself.</p>
<p>The ESTATE family also includes variants built around tweaked versions of the AES block cipher. We do not implement those variants in this library.</p>
<p><b>Similar Algorithms:</b> <a class="el" href="algorithms.html#alg_gift_cofb">GIFT-COFB</a>, <a class="el" href="algorithms.html#alg_hyena">SUNDAE-GIFT</a>, <a class="el" href="algorithms.html#alg_estate">HYENA</a></p>
<h1><a class="anchor" id="alg_forkae"></a>
ForkAE</h1>
<p><b>Definition:</b> <a class="el" href="forkae_8h.html">forkae.h</a></p>
<p>ForkAE is a family of authenticated encryption algorithms based on a modified version of the SKINNY tweakable block cipher. The modifications introduce "forking" where each input block produces two output blocks for use in encryption and authentication. There are six members in the ForkAE family:</p>
<ul>
<li>PAEF-ForkSkinny-64-192 has a 128-bit key, a 48-bit nonce, and a 64-bit authentication tag. The associated data and plaintext are limited to 2<sup>16</sup> bytes. </li>
<li>PAEF-ForkSkinny-128-192 has a 128-bit key, a 48-bit nonce, and a 128-bit authentication tag. The associated data and plaintext are limited to 2<sup>17</sup> bytes. </li>
<li>PAEF-ForkSkinny-128-256 has a 128-bit key, a 112-bit nonce, and a 128-bit authentication tag. The associated data and plaintext are limited to 2<sup>17</sup> bytes. </li>
<li>PAEF-ForkSkinny-128-288 has a 128-bit key, a 104-bit nonce, and a 128-bit authentication tag. The associated data and plaintext are limited to 2<sup>57</sup> bytes. </li>
<li>SAEF-ForkSkinny-128-192 has a 128-bit key, a 56-bit nonce, and a 128-bit authentication tag. The associated data and plaintext may be unlimited in size. </li>
<li>SAEF-ForkSkinny-128-256 has a 128-bit key, a 120-bit nonce, and a 128-bit authentication tag. The associated data and plaintext may be unlimited in size.</li>
</ul>
<p>The PAEF variants support parallel encryption and decryption for higher throughput. The SAEF variants encrypt or decrypt blocks sequentially.</p>
<p>ForkAE is designed to be efficient on small packet sizes so most of the PAEF algorithms have a limit of 64k or 128k on the amount of payload in a single packet. Obviously the input can be split into separate packets for larger amounts of data.</p>
<p><b>Recommendation:</b> The specification recommends PAEF-ForkSkinny-128-288.</p>
<h1><a class="anchor" id="alg_gift_cofb"></a>
GIFT-COFB</h1>
<p><b>Definition:</b> <a class="el" href="gift-cofb_8h.html">gift-cofb.h</a>, <a class="el" href="gift-cofb-masked_8h.html">gift-cofb-masked.h</a></p>
<p>GIFT-COFB is an authenticated encryption algorithm that combines the COFB (COmbined FeedBack) block cipher mode with the bit-sliced version of the GIFT-128 block cipher. The algorithm has a 128-bit key, a 128-bit nonce, and a 128-bit authentication tag.</p>
<p>The GIFT-128 block cipher was designed with hardware FPGA/ASIC implementations in mind, but with the <a href="https://eprint.iacr.org/2020/412.pdf">fixsliced</a> representation it is possible to acheive good software performance as well. This library implements fixslicing by default.</p>
<p>GIFT-COFB is a single-pass encryption algorithm, compared to the two-pass algorithm used by SUNDAE-GIFT. Out of all the GIFT-128 based submissions to NIST, GIFT-COFB has the best software performance, although HYENA is fairly close.</p>
<p>This library also implements a masked version of GIFT-COFB to provide protection against power analysis side channels.</p>
<p><b>Similar Algorithms:</b> <a class="el" href="algorithms.html#alg_sundae_gift">SUNDAE-GIFT</a>, <a class="el" href="algorithms.html#alg_hyena">HYENA</a>, <a class="el" href="algorithms.html#alg_estate">ESTATE</a></p>
<h1><a class="anchor" id="alg_gimli"></a>
Gimli</h1>
<p><b>Definition:</b> <a class="el" href="gimli24_8h.html">gimli24.h</a>, <a class="el" href="gimli24-masked_8h_source.html">gimli24-masked.h</a></p>
<p>GIMLI-24-CIPHER has a 256-bit key, a 128-bit nonce, and a 128-bit tag. It is the spiritual successor to the widely used ChaCha20 and has a similar design.</p>
<p>The library also includes an implementation of the hash algorithm GIMLI-24-HASH in both regular hashing and XOF modes.</p>
<p>This library also provides a masked implementation of Gimli.</p>
<h1><a class="anchor" id="alg_grain_128aead"></a>
Grain-128AEAD</h1>
<p><b>Definition:</b> <a class="el" href="grain128_8h.html">grain128.h</a></p>
<p>Grain-128AEAD is an authenticated encryption algorithm based around a combination of a 128-bit linear feedback shift register (LFSR) and a 128-bit non-linear feedback shift register (NFSR). It is a member of the Grain family of stream ciphers.</p>
<h1><a class="anchor" id="alg_hyena"></a>
HYENA</h1>
<p><b>Definition:</b> <a class="el" href="hyena_8h.html">hyena.h</a></p>
<p>HYENA is an authenticated encryption algorithm that implements a hybrid feedback mode where a mixture of plaintext and ciphertext are mixed into the state each block operation.</p>
<p>HYENA has a 128-bit key, a 96-bit nonce, and a 128-bit authentication tag. It makes a single pass over the associated data and plaintext.</p>
<p>The block cipher in HYENA is the nibble-based version of GIFT-128. This makes HYENA slightly slower than GIFT-COFB in this implementation because nibble-based GIFT-128 is implemented as a wrapper around the bit-sliced version. Using the bit-sliced version of GIFT-128 with HYENA would make it slightly faster than GIFT-COFB.</p>
<p>Note: This library implements both the v1 and v2 versions of HYENA from the authors. The v1 version has a known forgery attack, but is provided because it is part of the second round algorithm set. The v2 version should be used in practice.</p>
<p><b>Similar Algorithms:</b> <a class="el" href="algorithms.html#alg_gift_cofb">GIFT-COFB</a>, <a class="el" href="algorithms.html#alg_hyena">SUNDAE-GIFT</a>, <a class="el" href="algorithms.html#alg_estate">ESTATE</a></p>
<h1><a class="anchor" id="alg_isap"></a>
ISAP</h1>
<p><b>Definition:</b> <a class="el" href="isap_8h.html">isap.h</a></p>
<p>ISAP is a family of authenticated encryption algorithms that are built around the Keccak-p[400] or ASCON permutations. There are four algorithms in the family, each of which have a 128-bit key, a 128-bit nonce, and a 128-bit tag:</p>
<ul>
<li>ISAP-K-128A based around the Keccak-p[400] permutation with a reduced number of rounds. </li>
<li>ISAP-A-128A based around the ASCON permutation with a reduced number of rounds. </li>
<li>ISAP-K-128 based around the Keccak-p[400] permutation. </li>
<li>ISAP-A-128 based around the ASCON permutation.</li>
</ul>
<p>ISAP is designed to provide some protection against adversaries using differential power analysis to determine the key. The downside is that key setup is very slow. The Keccak-p[400] permutation is slower than ASCON on 32-bit platforms.</p>
<p><b>Recommendation:</b> The specification recommends ISAP-K-128A, although ISAP-A-128A may be a better choice on 32-bit platforms for performance reasons.</p>
<h1><a class="anchor" id="alg_knot"></a>
KNOT</h1>
<p><b>Definition:</b> <a class="el" href="knot_8h.html">knot.h</a></p>
<p>KNOT is a family of authenticated encryption and hash algorithms built around a permutation and the MonkeyDuplex sponge construction. The family members are:</p>
<ul>
<li>KNOT-AEAD-128-256 with a 128-bit key, a 128-bit nonce, and a 128-bit tag, built around a 256-bit permutation. </li>
<li>KNOT-AEAD-128-384 with a 128-bit key, a 128-bit nonce, and a 128-bit tag, built around a 384-bit permutation. </li>
<li>KNOT-AEAD-192-384 with a 192-bit key, a 192-bit nonce, and a 192-bit tag, built around a 384-bit permutation. </li>
<li>KNOT-AEAD-256-512 with a 256-bit key, a 256-bit nonce, and a 256-bit tag, built around a 512-bit permutation. </li>
<li>KNOT-HASH-256-256 with a 256-bit hash output, built around a 256-bit permutation. </li>
<li>KNOT-HASH-256-384 with a 256-bit hash output, built around a 384-bit permutation. </li>
<li>KNOT-HASH-384-384 with a 384-bit hash output, built around a 384-bit permutation. </li>
<li>KNOT-HASH-512-512 with a 512-bit hash output, built around a 512-bit permutation.</li>
</ul>
<p>This library also provides masked implementations of all KNOT encryption algorithms.</p>
<p><b>Recommendation:</b> The specification recommends KNOT-AEAD-128-256 and KNOT-HASH-256-256.</p>
<h1><a class="anchor" id="alg_lotus"></a>
LOTUS-AEAD and LOCUS-AEAD</h1>
<p><b>Definition:</b> <a class="el" href="lotus-locus_8h.html">lotus-locus.h</a></p>
<p>LOTUS-AEAD and LOCUS-AEAD are authenticated encryption algorithms that are based around a tweakable variant of the GIFT-64 block cipher called TweGIFT-64. Both AEAD algorithms have a 128-bit key, a 128-bit nonce, and a 64-bit tag.</p>
<p>The two algorithms have the same key initialization, associated data processing, and tag generation mechanisms. They differ in how the input is encrypted with TweGIFT-64.</p>
<p>LOTUS-AEAD uses a method similar to the block cipher mode OTR. TweGIFT-64 is essentially converted into a 128-bit block cipher using a Feistel construction and four TweGIFT-64 block operations every 16 bytes of input.</p>
<p>LOCUS-AEAD uses a method similar to the block cipher mode OCB with two TweGIFT-64 block operations for every 8 bytes of input. LOCUS-AEAD requires both the block encrypt and block decrypt operations of TweGIFT-64, which increases the overall code size. LOTUS-AEAD only needs the block encrypt operation.</p>
<p><b>Recommendation:</b> The specification recommends LOTUS-AEAD.</p>
<h1><a class="anchor" id="alg_mixfeed"></a>
mixFeed</h1>
<p>Based on AES. Not implemented.</p>
<h1><a class="anchor" id="alg_orange"></a>
ORANGE</h1>
<p><b>Definition:</b> <a class="el" href="orange_8h.html">orange.h</a></p>
<p>ORANGE is a family of algorithms built around the PHOTON-256 permutation. There are two members of the family at present:</p>
<ul>
<li>ORANGE-Zest is an authenticated encryption algorithm with a 128-bit key, a 128-bit nonce, and a 128-bit tag. </li>
<li>ORANGISH is a hash algorithm with a 256-bit output.</li>
</ul>
<h1><a class="anchor" id="alg_oribatida"></a>
Oribatida</h1>
<p><b>Definition:</b> <a class="el" href="oribatida_8h.html">oribatida.h</a></p>
<p>Oribatida is a family of authenticated encryption algorithms based on the SimP-256 and SimP-192 permutations which are built around reduced-round variants of the Simon-128-128 and Simon-96-96 block ciphers. There are two algorithms in the family:</p>
<ul>
<li>Oribatida-256-64 with a 128-bit key, a 128-bit nonce, and a 128-bit tag, built around the SimP-256 permutation. </li>
<li>Oribatida-192-96 with a 128-bit key, a 64-bit nonce, and a 96-bit tag, built around the SimP-192 permutation.</li>
</ul>
<p><b>Recommendation:</b> The specification recommends Oribatida-256-64.</p>
<h1><a class="anchor" id="alg_photon_beetle"></a>
PHOTON-Beetle</h1>
<p><b>Definition:</b> <a class="el" href="photon-beetle_8h.html">photon-beetle.h</a></p>
<p>PHOTON-Beetle is a family of authenticated encryption algorithms based on the PHOTON-256 permutation and using the Beetle sponge mode. There are three algorithms in the family:</p>
<ul>
<li>PHOTON-Beetle-AEAD-ENC-128 with a 128-bit key, a 128-bit nonce, and a 128-bit tag. Data is handled in 16 byte blocks. </li>
<li>PHOTON-Beetle-AEAD-ENC-32 with a 128-bit key, a 128-bit nonce, and a 128-bit tag. Data is handled in 4 byte blocks. </li>
<li>PHOTON-Beetle-Hash with a 256-bit hash output. The initial data is handled as a 16 byte block, and then the remaining bytes are processed in 4 byte blocks.</li>
</ul>
<p><b>Recommendation:</b> The specification recommends PHOTON-Beetle-AEAD-ENC-128.</p>
<h1><a class="anchor" id="alg_pyjamask"></a>
Pyjamask</h1>
<p><b>Definition:</b> <a class="el" href="pyjamask_8h.html">pyjamask.h</a>, <a class="el" href="pyjamask-masked_8h.html">pyjamask-masked.h</a></p>
<p>Pyjamask AEAD is a family of authenticated encryption algorithms that are built around the Pyjamask-128 and Pyjamask-96 block ciphers in OCB mode. Pyjamask-128-AEAD has a 128-bit key, a 96-bit nonce, and a 128-bit authentication tag. Pyjamask-96-AEAD has a 128-bit key, a 64-bit nonce, and a 96-bit authentication tag.</p>
<p>Pyjamask is claimed to be resistant against power analysis side channels when implemented as a masked block cipher. This library implements both the masked and unmasked versions of Pyjamask.</p>
<p>The implementation of the block cipher in this library is very slow at the moment (patches welcome to address this).</p>
<p>Note that OCB is covered by patents so it may not be usable in all applications. Open source applications should be covered, but for others you will need to contact the patent authors to find out if you can use it or if a paid license is required.</p>
<p>License information: <a href="https://web.cs.ucdavis.edu/~rogaway/ocb/license.htm">https://web.cs.ucdavis.edu/~rogaway/ocb/license.htm</a></p>
<p><b>Recommendation:</b> The specification recommends Pyjamask-128-AEAD.</p>
<h1><a class="anchor" id="alg_romulus"></a>
Romulus</h1>
<p><b>Definition:</b> <a class="el" href="romulus_8h.html">romulus.h</a></p>
<p><b>Nonce Reuse:</b> Resistant against nonce reuse as long as the combination of the associated data (AD) and plaintext is unique.</p>
<p>Romulus is a family of authenticated encryption algorithms that are built around the SKINNY-128 tweakable block cipher. There are six members in the family:</p>
<ul>
<li>Romulus-N1 has a 128-bit key, a 128-bit nonce, and a 128-bit tag, based around the SKINNY-128-384 tweakable block cipher. This is the primary member of the family. </li>
<li>Romulus-N2 has a 128-bit key, a 96-bit nonce, and a 128-bit tag, based around the SKINNY-128-384 tweakable block cipher. </li>
<li>Romulus-N3 has a 128-bit key, a 96-bit nonce, and a 128-bit tag, based around the SKINNY-128-256 tweakable block cipher. </li>
<li>Romulus-M1 has a 128-bit key, a 128-bit nonce, and a 128-bit tag, based around the SKINNY-128-384 tweakable block cipher. </li>
<li>Romulus-M2 has a 128-bit key, a 96-bit nonce, and a 128-bit tag, based around the SKINNY-128-384 tweakable block cipher. </li>
<li>Romulus-M3 has a 128-bit key, a 96-bit nonce, and a 128-bit tag, based around the SKINNY-128-256 tweakable block cipher.</li>
</ul>
<p>The Romulus-M variants are resistant to nonce reuse as long as the combination of the associated data and plaintext is unique. If the same associated data and plaintext are reused under the same nonce, then the scheme will leak that the same plaintext has been sent for a second time but will not reveal the plaintext itself.</p>
<p>The Romulus block padding and domain separation schemes are quite complex, so it is one of the larger algorithms to implement in software.</p>
<p><b>Recommendation:</b> The specification recommends Romulus-N1, or Romulus-M1 if resistance against nonce reuse is desirable. The specification recommends that Romulus should be paired with the SKINNY-tk2-HASH and SKINNY-tk3-HASH algorithms from the <a class="el" href="algorithms.html#alg_skinny_aead">SKINNY-AEAD</a> submission if hashing is required.</p>
<h1><a class="anchor" id="alg_saeaes"></a>
SAEAES</h1>
<p>Based on AES. Not implemented.</p>
<h1><a class="anchor" id="alg_saturnin"></a>
Saturnin</h1>
<p><b>Definition:</b> <a class="el" href="saturnin_8h.html">saturnin.h</a></p>
<p>Saturnin is a block cipher mode with a 256-bit key, a 128-bit nonce, and a 256-bit authentication tag. It is built around a bit-sliced variant of AES that has a 256-bit block compared with AES's traditional 128-bit block. The authors claim that the increased block size and the 256-bit key size should give added protection against quantum computers.</p>
<p>Saturnin comes in two variants: SATURNIN-CTR-Cascade and SATURNIN-Short. SATURNIN-CTR-Cascade works on arbitrary-sized inputs using a two-pass combination of CTR mode with the Cascade authentication mode.</p>
<p>SATURNIN-Short is designed to work on short inputs of no more than 15 bytes with no assoicated data and involves only a single block operation. It is very fast compared to other NIST submissions on short data.</p>
<p>The library also includes an implementation of the companion hash algorithm SATURNIN-Hash.</p>
<p><b>Recommendation:</b> SATURNIN-CTR-Cascade is the recommended variant from the NIST submission.</p>
<h1><a class="anchor" id="alg_skinny_aead"></a>
SKINNY-AEAD</h1>
<p><b>Definition:</b> <a class="el" href="skinny-aead_8h.html">skinny-aead.h</a></p>
<p>SKINNY-AEAD is a family of authenticated encryption algorithms that are built around the SKINNY tweakable block cipher. There are six members in the family:</p>
<ul>
<li>SKINNY-AEAD-M1 has a 128-bit key, a 128-bit nonce, and a 128-bit tag, based around the SKINNY-128-384 tweakable block cipher. </li>
<li>SKINNY-AEAD-M2 has a 128-bit key, a 96-bit nonce, and a 128-bit tag, based around the SKINNY-128-384 tweakable block cipher. </li>
<li>SKINNY-AEAD-M3 has a 128-bit key, a 128-bit nonce, and a 64-bit tag, based around the SKINNY-128-384 tweakable block cipher. </li>
<li>SKINNY-AEAD-M4 has a 128-bit key, a 96-bit nonce, and a 64-bit tag, based around the SKINNY-128-384 tweakable block cipher. </li>
<li>SKINNY-AEAD-M5 has a 128-bit key, a 96-bit nonce, and a 128-bit tag, based around the SKINNY-128-256 tweakable block cipher. </li>
<li>SKINNY-AEAD-M6 has a 128-bit key, a 96-bit nonce, and a 64-bit tag, based around the SKINNY-128-256 tweakable block cipher.</li>
</ul>
<p>This library's implementation of SKINNY-128-384 requires 464 bytes of RAM for the key schedule, which makes it one of the heavier algorithms amongst the NIST submissions when it comes to RAM size.</p>
<p>If the SKINNY_128_SMALL_SCHEDULE macro is defined to 1 in the "internal-skinny128.h" header, then an alternative implementation is used that reduces the key schedule for SKINNY-128-384 to 48 bytes, and the key schedule for SKINNY-128-256 to 32 bytes. The full key schedule is expanded on the fly, which comes at the cost of performance. The AVR implementation enables the small schedule version by default.</p>
<p>The SKINNY-AEAD family also includes two hash algorithms:</p>
<ul>
<li>SKINNY-tk3-HASH with a 256-bit hash output, based around the SKINNY-128-384 tweakable block cipher. </li>
<li>SKINNY-tk2-HASH with a 256-bit hash output, based around the SKINNY-128-256 tweakable block cipher.</li>
</ul>
<p>The hash algorithms use a more memory-efficient version of SKINNY-128 that expands the key schedule on the fly because the key needs to change every block. It does however have a performance cost to do this.</p>
<p><b>Recommendation:</b> SKINNY-AEAD-M1 and SKINNY-tk3-HASH are the recommended variants from the NIST submission.</p>
<h1><a class="anchor" id="alg_sparkle"></a>
SPARKLE</h1>
<p><b>Definition:</b> <a class="el" href="sparkle_8h.html">sparkle.h</a></p>
<p>SPARKLE is a family of encryption and hash algorithms that are based around the SPARKLE permutation. There are three versions of the permutation with 256-bit, 384-bit, and 512-bit state sizes. The algorithms in the family are:</p>
<ul>
<li>Schwaemm256-128 with a 128-bit key, a 256-bit nonce, and a 128-bit tag. </li>
<li>Schwaemm192-192 with a 192-bit key, a 192-bit nonce, and a 192-bit tag. </li>
<li>Schwaemm128-128 with a 128-bit key, a 128-bit nonce, and a 128-bit tag. </li>
<li>Schwaemm256-256 with a 256-bit key, a 256-bit nonce, and a 256-bit tag. </li>
<li>Esch256 hash algorithm with a 256-bit digest output. </li>
<li>Esch384 hash algorithm with a 384-bit digest output.</li>
</ul>
<p>SPARKLE has good performance in software on 32-bit platforms.</p>
<p><b>Recommendation:</b> Schwaemm256-128 and Esch256 are the recommended variants from the NIST submission.</p>
<h1><a class="anchor" id="alg_spix"></a>
SPIX</h1>
<p><b>Definition:</b> <a class="el" href="spix_8h.html">spix.h</a></p>
<p>SPIX is an authenticated encryption algorithm with a 128-bit key, a 128-bit nonce, and a 128-bit tag. It uses the MonkeyDuplex construction on top of the 256-bit sLiSCP-light permutation.</p>
<p>This library also provides a masked implementation of SPIX.</p>
<p><b>Similar Algorithms:</b> <a class="el" href="algorithms.html#alg_ace">ACE</a>, <a class="el" href="algorithms.html#alg_spoc">SpoC</a></p>
<h1><a class="anchor" id="alg_spoc"></a>
SpoC</h1>
<p><b>Definition:</b> <a class="el" href="spoc_8h.html">spoc.h</a></p>
<p>SpoC is a family of authenticated encryption algorithms with two members, SpoC-128 and Spoc-64. The algorithms use a Beetle-like sponge construction built on top of the sLiSCP-light permutation.</p>
<ul>
<li>Spoc-128 has a 128-bit key, a 128-bit nonce, and a 128-bit tag. It is built around the 256-bit version of the sLiSCP-light permutation. </li>
<li>Spoc-64 has a 128-bit key, a 128-bit nonce, and a 64-bit tag. It is built around the 192-bit version of the sLiSCP-light permutation. This is the primary member of the family.</li>
</ul>
<p>Spoc-128 has good performance on small packets (16 bytes or less) on 32-bit embedded platforms.</p>
<p>This library also provides masked implementations of SpoC-128 and SpoC-64.</p>
<p><b>Recommendation:</b> The specification recommends SpoC-64.</p>
<p><b>Similar Algorithms:</b> <a class="el" href="algorithms.html#alg_ace">ACE</a>, <a class="el" href="algorithms.html#alg_spix">SPIX</a></p>
<h1><a class="anchor" id="alg_spook"></a>
Spook</h1>
<p><b>Definition:</b> <a class="el" href="spook_8h.html">spook.h</a>, <a class="el" href="spook-masked_8h.html">spook-masked.h</a></p>
<p>Spook is a family of authenticated encryption algorithms that are built around a tweakable block cipher and a permutation.</p>
<p>If the tweakable block cipher is implemented as a masked block cipher, then Spook provides protection against power analysis side channels. This library implements both the masked and unmasked versions of Spook.</p>
<p>There are four members in the Spook family:</p>
<ul>
<li>Spook-128-512-su with a 128-bit key, a 128-bit nonce, and a 128-bit tag. Internally the algorithm uses a 512-bit permutation. This is the primary member of the family. </li>
<li>Spook-128-384-su with a 128-bit key, a 128-bit nonce, and a 128-bit tag. Internally the algorithm uses a 384-bit permutation. </li>
<li>Spook-128-512-mu with a 128-bit key, a 128-bit public tweak, a 128-bit nonce, and a 128-bit tag. Internally the algorithm uses a 512-bit permutation. </li>
<li>Spook-128-512-mu with a 128-bit key, a 128-bit public tweak, a 128-bit nonce, and a 128-bit tag. Internally the algorithm uses a 384-bit permutation.</li>
</ul>
<p>In this library, the "mu" (multi-user) variants combine the 128-bit key and the 128-bit public tweak into a single 256-bit key value. Applications can either view this as a cipher with a 256-bit key, or they can split the key value into secret and public halves. Even with the use of 256-bit keys, Spook only has 128-bit security.</p>
<p><b>Recommendation:</b> The specification recommends Spook-128-512-su.</p>
<h1><a class="anchor" id="alg_subterranean"></a>
Subterranean</h1>
<p><b>Definition:</b> <a class="el" href="subterranean_8h.html">subterranean.h</a></p>
<p>Subterranean (technically "Subterranean 2.0") is a family of algorithms built around the 257-bit Subterranean permutation:</p>
<ul>
<li>Subterranean is an authenticated encryption algorithm with a 128-bit key, a 128-bit nonce, and a 128-bit tag. </li>
<li>Subterranean-Hash is a hash algorithm with a 256-bit output.</li>
</ul>
<p>The Subterranean permutation is intended for hardware implementation. It is not structured for efficient software implementation. Despite that, this library's implementation is still fairly competitive, with similar performance to SKINNY-based authenticated encryption schemes like <a class="el" href="algorithms.html#alg_skinny_aead">SKINNY-AEAD</a>.</p>
<h1><a class="anchor" id="alg_sundae_gift"></a>
SUNDAE-GIFT</h1>
<p><b>Definition:</b> <a class="el" href="sundae-gift_8h.html">sundae-gift.h</a></p>
<p><b>Nonce Reuse:</b> Resistant against nonce reuse as long as the combination of the associated data (AD) and plaintext is unique.</p>
<p>The SUNDAE-GIFT family consists of several related algorithms:</p>
<ul>
<li>SUNDAE-GIFT-0 with a 128-bit key, a 0-bit nonce, and 128-bit tag. </li>
<li>SUNDAE-GIFT-64 with a 128-bit key, a 64-bit nonce, and 128-bit tag. </li>
<li>SUNDAE-GIFT-96 with a 128-bit key, a 96-bit nonce, and 128-bit tag. This is the primary member of the family. </li>
<li>SUNDAE-GIFT-128 with a 128-bit key, a 128-bit nonce, and 128-bit tag.</li>
</ul>
<p>SUNDAE-GIFT is built around the GIFT-128 block cipher in bit-sliced mode. Two passes are made over the input data. The first pass computes the authentication tag over the nonce, associated data, and plaintext. The second pass encrypts the plaintext to produce the ciphertext.</p>
<p>SUNDAE-GIFT is resistant against nonce reuse as long as the combination of the associated data and plaintext is unique.</p>
<p>If a nonce is reused (or there is no nonce in the case of SUNDAE-GIFT-0), then two packets with the same associated data and plaintext will encrypt to the same ciphertext. This will leak that the same plaintext has been sent for a second time but will not reveal the plaintext itself.</p>
<p><b>Recommendation:</b> SUNDAE-GIFT-96 is the recommended variant in the NIST submission, with SUNDAE-GIFT-0 as the next-recommended variant.</p>
<p><b>Similar Algorithms:</b> <a class="el" href="algorithms.html#alg_gift_cofb">GIFT-COFB</a>, <a class="el" href="algorithms.html#alg_hyena">HYENA</a>, <a class="el" href="algorithms.html#alg_estate">ESTATE</a></p>
<h1><a class="anchor" id="alg_tinyjambu"></a>
TinyJAMBU</h1>
<p><b>Definition:</b> <a class="el" href="tinyjambu_8h.html">tinyjambu.h</a></p>
<p>TinyJAMBU is a family of encryption algorithms that are built around a lightweight 128-bit permutation. There are three variants of TinyJAMBU with different key sizes:</p>
<ul>
<li>TinyJAMBU-128 with a 128-bit key, a 96-bit nonce, and a 64-bit tag. </li>
<li>TinyJAMBU-192 with a 192-bit key, a 96-bit nonce, and a 64-bit tag. </li>
<li>TinyJAMBU-256 with a 256-bit key, a 96-bit nonce, and a 64-bit tag.</li>
</ul>
<p>TinyJAMBU has one of the smallest RAM and flash memory footprints out of all of the NIST algorithms. Performance of TinyJAMBU-128 is comparable to this library's implementation of GIMLI-24.</p>
<p><b>Recommendation:</b> TinyJAMBU-128 is the recommended variant in the NIST submission. Use TinyJAMBU-256 if you need a greater security margin.</p>
<h1><a class="anchor" id="alg_wage"></a>
WAGE</h1>
<p>WAGE is an authenticated encryption algorithm that is built around the 259-bit WAGE permutation. The algorithm has a 128-bit key, a 128-bit nonce, and a 128-bit authentication tag. It is an evolution of the WG series of stream ciphers.</p>
<h1><a class="anchor" id="alg_xoodyak"></a>
Xoodyak</h1>
<p><b>Definition:</b> <a class="el" href="xoodyak_8h.html">xoodyak.h</a></p>
<p>Xoodyak is an authenticated encryption and hash algorithm pair based around the 384-bit Xoodoo permutation that is similar in structure to Keccak but is more efficient than Keccak on 32-bit embedded devices. The Cyclist mode of operation is used to convert the permutation into a sponge for the higher-level algorithms.</p>
<p>The Xoodyak encryption mode has a 128-bit key, a 128-bit nonce, and a 128-bit authentication tag. The Xoodyak hashing mode has a 256-bit fixed hash output and can also be used as an extensible output function (XOF).</p>
<p>The Xoodyak specification describes a re-keying mechanism where the key for one packet is used to derive the key to use on the next packet. This provides some resistance against side channel attacks by making the session key a moving target. This library does not currently implement re-keying.</p>
<p>This library also provides a masked implementation of Xoodyak.</p>
<p><b>Recommendation:</b> There is only one encryption algorithm and one hash algorithm in the Xoodyak family, so they the recommended ones.</p>
<h1><a class="anchor" id="alg_internal"></a>
Internal block operations</h1>
<p>Many of the algorithms are built on top of internal block ciphers and sponge block operations. Some of these operations are shared between multiple algorithms so they are provided in a common internal location.</p>
<p>All of the internal block operations are implemented in source files that start with the <code>internal-</code> prefix. They are not intended to be part of the public API for the AEAD algorithms.</p>
<p>If you wish to improve the performance of an algorithm implementation with assembly code or vector instructions, then the best place to start is with the internal block operation code. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 1 2020 06:53:02 for Lightweight Cryptography Primitives by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
